<?xml version="1.0" encoding="UTF-8" ?>
<class name="TileMap" inherits="Node2D" version="4.0">
	<brief_description>
		Node for 2D tile-based maps.
	</brief_description>
	<description>
		Node for 2D tile-based maps. Tilemaps use a [TileSet] which contain a list of tiles (textures plus optional collision, navigation, and/or occluder shapes) which are used to create grid-based maps.
		When doing physics queries against the tilemap, the cell coordinates are encoded as [code]metadata[/code] for each detected collision shape returned by methods such as [method PhysicsDirectSpaceState2D.intersect_shape], [method PhysicsDirectBodyState2D.get_contact_collider_shape_metadata] etc.
	</description>
	<tutorials>
<<<<<<< HEAD
		<link title="Using Tilemaps">https://docs.godotengine.org/en/3.2/tutorials/2d/using_tilemaps.html</link>
=======
		<link title="Using Tilemaps">https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html</link>
>>>>>>> 5d9cab3aeb3c62df6b7b44e6e68c0ebbb67f7a45
		<link title="2D Platformer Demo">https://godotengine.org/asset-library/asset/120</link>
		<link title="2D Isometric Demo">https://godotengine.org/asset-library/asset/112</link>
		<link title="2D Hexagonal Demo">https://godotengine.org/asset-library/asset/111</link>
		<link title="2D Navigation Astar Demo">https://godotengine.org/asset-library/asset/519</link>
		<link title="2D Role Playing Game Demo">https://godotengine.org/asset-library/asset/520</link>
		<link title="2D Kinematic Character Demo">https://godotengine.org/asset-library/asset/113</link>
	</tutorials>
	<methods>
		<method name="clear">
			<return type="void">
			</return>
			<description>
				Clears all cells.
			</description>
		</method>
		<method name="fix_invalid_tiles">
			<return type="void">
			</return>
			<description>
				Clears cells that do not exist in the tileset.
			</description>
		</method>
		<method name="get_cell_alternative_tile" qualifiers="const">
			<return type="int">
			</return>
			<argument index="0" name="coords" type="Vector2i">
			</argument>
			<description>
			</description>
		</method>
		<method name="get_cell_atlas_coords" qualifiers="const">
			<return type="Vector2i">
			</return>
			<argument index="0" name="coords" type="Vector2i">
			</argument>
			<description>
<<<<<<< HEAD
				Returns the coordinate (subtile column and row) of the autotile variation in the tileset. Returns a zero vector if the cell doesn't have autotiling.
=======
>>>>>>> 5d9cab3aeb3c62df6b7b44e6e68c0ebbb67f7a45
			</description>
		</method>
		<method name="get_cell_source_id" qualifiers="const">
			<return type="int">
			</return>
			<argument index="0" name="coords" type="Vector2i">
			</argument>
			<description>
			</description>
		</method>
		<method name="get_neighbor_cell" qualifiers="const">
			<return type="Vector2i">
			</return>
			<argument index="0" name="coords" type="Vector2i">
			</argument>
			<argument index="1" name="neighbor" type="int" enum="TileSet.CellNeighbor">
			</argument>
			<description>
			</description>
		</method>
		<method name="get_surrounding_tiles">
			<return type="Vector2i[]">
			</return>
			<argument index="0" name="coords" type="Vector2i">
			</argument>
			<description>
			</description>
		</method>
		<method name="get_used_cells" qualifiers="const">
			<return type="Vector2i[]">
			</return>
			<description>
				Returns a [Vector2] array with the positions of all cells containing a tile from the tileset (i.e. a tile index different from [code]-1[/code]).
			</description>
		</method>
<<<<<<< HEAD
		<method name="get_used_cells_by_id" qualifiers="const">
			<return type="Array">
			</return>
			<argument index="0" name="id" type="int">
			</argument>
			<description>
				Returns an array of all cells with the given tile index specified in [code]id[/code].
			</description>
		</method>
=======
>>>>>>> 5d9cab3aeb3c62df6b7b44e6e68c0ebbb67f7a45
		<method name="get_used_rect">
			<return type="Rect2">
			</return>
			<description>
				Returns a rectangle enclosing the used (non-empty) tiles of the map.
			</description>
		</method>
		<method name="map_to_world" qualifiers="const">
			<return type="Vector2">
			</return>
			<argument index="0" name="map_position" type="Vector2i">
			</argument>
			<description>
				Returns the local position corresponding to the given tilemap (grid-based) coordinates.
			</description>
		</method>
		<method name="set_cell">
			<return type="void">
			</return>
<<<<<<< HEAD
			<argument index="0" name="x" type="int">
			</argument>
			<argument index="1" name="y" type="int">
			</argument>
			<argument index="2" name="tile" type="int">
			</argument>
			<argument index="3" name="flip_x" type="bool" default="false">
			</argument>
			<argument index="4" name="flip_y" type="bool" default="false">
			</argument>
			<argument index="5" name="transpose" type="bool" default="false">
			</argument>
			<argument index="6" name="autotile_coord" type="Vector2" default="Vector2( 0, 0 )">
			</argument>
			<description>
				Sets the tile index for the cell given by a Vector2.
				An index of [code]-1[/code] clears the cell.
				Optionally, the tile can also be flipped, transposed, or given autotile coordinates. The autotile coordinate refers to the column and row of the subtile.
				[b]Note:[/b] Data such as navigation polygons and collision shapes are not immediately updated for performance reasons.
				If you need these to be immediately updated, you can call [method update_dirty_quadrants].
				Overriding this method also overrides it internally, allowing custom logic to be implemented when tiles are placed/removed:
				[codeblock]
				func set_cell(x, y, tile, flip_x=false, flip_y=false, transpose=false, autotile_coord=Vector2())
				    # Write your custom logic here.
				    # To call the default method:
				    .set_cell(x, y, tile, flip_x, flip_y, transpose, autotile_coord)
				[/codeblock]
			</description>
		</method>
		<method name="set_cellv">
			<return type="void">
			</return>
			<argument index="0" name="position" type="Vector2">
			</argument>
			<argument index="1" name="tile" type="int">
			</argument>
			<argument index="2" name="flip_x" type="bool" default="false">
			</argument>
			<argument index="3" name="flip_y" type="bool" default="false">
			</argument>
			<argument index="4" name="transpose" type="bool" default="false">
			</argument>
			<description>
				Sets the tile index for the given cell.
				An index of [code]-1[/code] clears the cell.
				Optionally, the tile can also be flipped or transposed.
				[b]Note:[/b] Data such as navigation polygons and collision shapes are not immediately updated for performance reasons.
				If you need these to be immediately updated, you can call [method update_dirty_quadrants].
			</description>
		</method>
		<method name="set_collision_layer_bit">
			<return type="void">
			</return>
			<argument index="0" name="bit" type="int">
=======
			<argument index="0" name="coords" type="Vector2i">
>>>>>>> 5d9cab3aeb3c62df6b7b44e6e68c0ebbb67f7a45
			</argument>
			<argument index="1" name="source_id" type="int" default="-1">
			</argument>
			<argument index="2" name="atlas_coords" type="Vector2i" default="Vector2i( -1, -1 )">
			</argument>
			<argument index="3" name="alternative_tile" type="int" default="-1">
			</argument>
			<description>
				Sets the tile index for the cell given by a Vector2i.
			</description>
		</method>
		<method name="update_dirty_quadrants">
			<return type="void">
			</return>
			<description>
				Updates the tile map's quadrants, allowing things such as navigation and collision shapes to be immediately used if modified.
			</description>
		</method>
		<method name="world_to_map" qualifiers="const">
			<return type="Vector2i">
			</return>
			<argument index="0" name="world_position" type="Vector2">
			</argument>
			<description>
				Returns the tilemap (grid-based) coordinates corresponding to the given local position.
			</description>
		</method>
	</methods>
	<members>
		<member name="cell_quadrant_size" type="int" setter="set_quadrant_size" getter="get_quadrant_size" default="16">
			The TileMap's quadrant size. Optimizes drawing by batching, using chunks of this size.
		</member>
<<<<<<< HEAD
		<member name="cell_size" type="Vector2" setter="set_cell_size" getter="get_cell_size" default="Vector2( 64, 64 )">
			The TileMap's cell size.
		</member>
		<member name="cell_tile_origin" type="int" setter="set_tile_origin" getter="get_tile_origin" enum="TileMap.TileOrigin" default="0">
			Position for tile origin. See [enum TileOrigin] for possible values.
		</member>
		<member name="cell_y_sort" type="bool" setter="set_y_sort_mode" getter="is_y_sort_mode_enabled" default="false">
			If [code]true[/code], the TileMap's direct children will be drawn in order of their Y coordinate.
		</member>
		<member name="centered_textures" type="bool" setter="set_centered_textures" getter="is_centered_textures_enabled" default="false">
			If [code]true[/code], the textures will be centered in the middle of each tile. This is useful for certain isometric or top-down modes when textures are made larger or smaller than the tiles (e.g. to avoid flickering on tile edges). The offset is still applied, but from the center of the tile. If used, [member compatibility_mode] is ignored.
			If [code]false[/code], the texture position start in the top-left corner unless [member compatibility_mode] is enabled.
		</member>
		<member name="collision_bounce" type="float" setter="set_collision_bounce" getter="get_collision_bounce" default="0.0">
			Bounce value for static body collisions (see [code]collision_use_kinematic[/code]).
		</member>
		<member name="collision_friction" type="float" setter="set_collision_friction" getter="get_collision_friction" default="1.0">
			Friction value for static body collisions (see [code]collision_use_kinematic[/code]).
		</member>
		<member name="collision_layer" type="int" setter="set_collision_layer" getter="get_collision_layer" default="1">
			The collision layer(s) for all colliders in the TileMap. See [url=https://docs.godotengine.org/en/3.2/tutorials/physics/physics_introduction.html#collision-layers-and-masks]Collision layers and masks[/url] in the documentation for more information.
		</member>
		<member name="collision_mask" type="int" setter="set_collision_mask" getter="get_collision_mask" default="1">
			The collision mask(s) for all colliders in the TileMap. See [url=https://docs.godotengine.org/en/3.2/tutorials/physics/physics_introduction.html#collision-layers-and-masks]Collision layers and masks[/url] in the documentation for more information.
		</member>
		<member name="collision_use_kinematic" type="bool" setter="set_collision_use_kinematic" getter="get_collision_use_kinematic" default="false">
			If [code]true[/code], TileMap collisions will be handled as a kinematic body. If [code]false[/code], collisions will be handled as static body.
		</member>
		<member name="collision_use_parent" type="bool" setter="set_collision_use_parent" getter="get_collision_use_parent" default="false">
			If [code]true[/code], this tilemap's collision shape will be added to the collision shape of the parent. The parent has to be a [CollisionObject2D].
=======
		<member name="show_collision" type="int" setter="set_collision_visibility_mode" getter="get_collision_visibility_mode" enum="TileMap.VisibilityMode" default="0">
>>>>>>> 5d9cab3aeb3c62df6b7b44e6e68c0ebbb67f7a45
		</member>
		<member name="show_navigation" type="int" setter="set_navigation_visibility_mode" getter="get_navigation_visibility_mode" enum="TileMap.VisibilityMode" default="0">
		</member>
		<member name="tile_set" type="TileSet" setter="set_tileset" getter="get_tileset">
			The assigned [TileSet].
		</member>
	</members>
	<signals>
		<signal name="changed">
			<description>
				Emitted when the [TileSet] of this TileMap changes.
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="VISIBILITY_MODE_DEFAULT" value="0" enum="VisibilityMode">
		</constant>
		<constant name="VISIBILITY_MODE_FORCE_HIDE" value="2" enum="VisibilityMode">
		</constant>
		<constant name="VISIBILITY_MODE_FORCE_SHOW" value="1" enum="VisibilityMode">
		</constant>
	</constants>
</class>
